/*
 *  linux/lib/string.c
 * 
 * 12、操作系统如何利用buffer_head中的 b_data，b_blocknr，b_dev，b_uptodate，b_dirt，b_count，b_lock，b_wait管理缓冲块的？
答：
buffer_head负责进程与缓冲块的数据交互，让数据在缓冲区中停留的时间尽可能长。
b_data指向缓冲块，用于找到缓冲块的位置。
进程与缓冲区及缓冲区与硬盘之间都是以缓冲块为单位进行数据交互的，而b_blocknr，b_dev唯一标识一个块，用于保证数据交换的正确性。另外缓冲区中的数据被越多进程共享，效率就越高，因此要让缓冲区中的数据块停留的时间尽可能久，而这正是由b_blocknr，b_dev决定的，内核在hash表中搜索缓冲块时，只看设备号与块号，只要缓冲块与硬盘数据的绑定关系还在，就认定数据块仍停留在缓冲块中，就可以直接用。
b_uptodate与b_dirt，是为了解决缓冲块与数据块的数据正确性问题而存在的。b_uptodate针对进程方向，如果b_uptodate为1，说明缓冲块的数据已经是数据块中最新的，可以支持进程共享缓冲块中的数据；如果b_uptodate为0，提醒内核缓冲块并没有用绑定的数据块中的数据更新，不支持进程共享该缓冲块。
b_dirt是针对硬盘方向的，b_dirt为1说明缓冲块的内容被进程方向的数据改写了，最终需要同步到硬盘上；b_dirt为0则说明不需要同步
b_count记录每个缓冲块有多少进程共享。 b_count大于0表明有进程在共享该缓冲块，当进程不需要共享缓冲块时，内核会解除该进程与缓冲块的关系，并将b_count数值减1，为0表明可以被当作新缓冲块来申请使用。
b_lock为1说明缓冲块正与硬盘交互，内核会拦截进程对该缓冲块的操作，以免发生错误，交互完成后，置0表明进程可以操作该缓冲块。
b_wait记录等待缓冲块的解锁而被挂起的进程，指向等待队列前面进程的task_struct。

13、详细分析多个进程（无父子关系）共享一个可执行程序的完整过程。
答：
假设有三个进程A、B、C，进程A先执行，之后是B最后是C，它们没有父子关系。A进程启动后会调用open函数打开该可执行文件，然后调用sys_read()函数读取文件内容,该函数最终会调用bread函数，该函数会分配缓冲块，进行设备到缓冲块的数据交换，因为此时为设备读入，时间较长，所以会给该缓冲块加锁，调用sleep_on函数，A进程被挂起，调用schedule()函数B进程开始执行。
B进程也首先执行open（）函数，虽然A和B打开的是相同的文件，但是彼此操作没有关系，所以B继承需要另外一套文件管理信息，通过open_namei()函数。B进程调用read函数，同样会调用bread（），由于此时内核检测到B进程需要读的数据已经进入缓冲区中，则直接返回，但是由于此时设备读没有完成，缓冲块以备加锁，所以B将因为等待而被系统挂起，之后调用schedule()函数。
C进程开始执行，但是同B一样，被系统挂起，调用schedule()函数，假设此时无其它进程，则系统0进程开始执行。
假设此时读操作完成，外设产生中断，中断服务程序开始工作。它给读取的文件缓冲区解锁并调用wake_up()函数，传递的参数是&bh->b_wait,该函数首先将C唤醒，此后中断服务程序结束，开始进程调度，此时C就绪，C程序开始执行，首先将B进程设为就绪态。C执行结束或者C的时间片削减为0时，切换到B进程执行。进程B也在sleep_on()函数中，调用schedule函数进程进程切换，B最终回到sleep_on函数，进程B开始执行，首先将进程A设为就绪态，同理当B执行完或者时间片削减为0时，切换到A执行，此时A的内核栈中tmp对应NULL，不会再唤醒进程了。

 *
 *  (C) 1991  Linus Torvalds
 */

#ifndef __GNUC__
#error I want gcc!
#endif

#define extern
#define inline
#define __LIBRARY__
#include <string.h>
